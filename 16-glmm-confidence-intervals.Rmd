# GLMM confidence intervals

help("pvalues",package="lme4") 

Confidence intervals on random effects or on predictions including the random effects in GLMMs are complicated. 

There is no one magic bullet if you are using the lme4 package. Various options make different assumptions and range from simple to complex. 

The single best resource aggregating information on this topic (and other issues involving GLMMs in R) is <http://glmm.wikidot.com/faq>. It's well worth skimming. 

Below we'll work through some the options. 

```{r}
library(tidyverse)
library(lme4)
d <- readRDS("data/generated//morph-geospiza-group.rds")
set.seed(1)
d <- d[sample(seq_len(nrow(d)), 700), ] # downsample for-speed 
```

```{r}
m <- lmer(log(beakh) ~ log_wingl_centered + mean_log_wingl_centered +
    (1 | taxon), data = d)
arm::display(m)
```


```{r, eval=FALSE}
ci <- list()
ci[[1]] <- confint(m, method = "Wald", oldNames = FALSE)
ci[[2]] <- confint(m, method = "profile", oldNames = FALSE)
ci[[3]] <- confint(m, method = "boot", oldNames = FALSE, nsim = 200, .progress="txt")

ci

arm::display(m)
```

Population level predictions with confidence intervals:

```{r}
predict_pop_ci <- function(model, newdata, alpha = 0.05) {
  # baseline prediction, on the linear predictor (logit) scale:
  pred0 <- predict(model, re.form = NA, newdata = newdata)
  # fixed-effects model matrix for new data
  X <- model.matrix(formula(model, fixed.only = TRUE)[-2],
    newdata)
  beta <- fixef(model) # fixed-effects coefficients
  V <- vcov(model) # variance-covariance matrix of beta
  pred.se <-
    sqrt(diag(X %*% V %*% t(X))) # std errors of predictions
  if (identical(class(model), "glmerMod")) {
    linkinv <- model@resp$family$linkinv # inverse-link function
  } else {
    linkinv <- I
  }
  # construct 95% Normal CIs on the link scale and
  # transform back to the response scale:
  crit <- -qnorm(alpha / 2)
  linkinv(tibble::tibble(
    fit = pred0,
    lwr = pred0 - crit * pred.se,
    upr = pred0 + crit * pred.se
  ))
}

new_data <- select(islandid, )
p <- predict_pop_ci(m, d)
p

newdata <- cbind(d, p)

ggplot(p, aes(aes))) + 
```
