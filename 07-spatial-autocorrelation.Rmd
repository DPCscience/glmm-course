# Spatial autocorrelation 

# Goals

- Learn to identify and deal with spatial autocorrelation through correlation structures in nlme
- Very briefly get introduced to the idea of GAMs

# Loading the data 

We will work with an example data set from the nlme package. This data set is
also used as an example in the accompanying textbook by Pinheiro and Bates.

```{r}
library(nlme)
library(tidyverse)
d <- Wheat2 # loaded with nlme
glimpse(d)
```

So far we have used the `lme` function from the nlme package to fit linear
mixed effect models. This package also has the function `gls`, which lets you
use the features of nlme when fitting linear models without random effects.

This data set represents yield from various varieties of wheat collected at
different latitudes and longitudes.

```{r}
m1 <- gls(yield ~ variety - 1, data = d)
m1
```

The nlme package comes with a built in function for plotting a semivariogram.
You can think of this like an inverse of a correlation of the residuals at
increasing distance. So low values correspond to high correlation and high
values correspond to low correlation. 

```{r}
plot(Variogram(m1, form = ~ latitude + longitude))
```

We can also extract and plot the residuals spatially ourselves. 

```{r}
d$res <- as.numeric(residuals(m1))
ggplot(d, aes(longitude, latitude, colour = res)) + 
  geom_point(size = 5) + scale_color_gradient2()
```

We can clearly see that the residuals have spatial clumping patterns. Why is this a problem?

If we look at the semivariogram that we plotted earlier, we can take a guess at
good initial starting values for a range value and nugget effect. The nugget
represents the intercept value and the range represents the distance at which
the semivariogram reaches 1.

```{r}
m2 <- update(m1, 
  corr = corSpher(c(30, 0.2), form = ~ latitude + longitude, nugget = TRUE))
m2
```

In fact, this is an example where if we don't give the correlation structure
decent starting values it comes up with the wrong answer:

```{r}
m3 <- update(m1, 
  corr = corSpher(form = ~ latitude + longitude, nugget = TRUE))
m3
```

Let's try plotting the residuals spatially and making another semivariogram.
Note again how it is critical that we use `type = "normalized"` in order to
incorporate the correlation structure into the residual calculations. 

```{r}
d$res2 <- as.numeric(residuals(m2, type = "normalized"))
ggplot(d, aes(longitude, latitude, colour = res2)) + geom_point(size = 5) +
  scale_color_gradient2()
plot(Variogram(m2, form = ~ latitude + longitude, resType = "normalized"))
```

That looks much better. 

We can also compare the models with AIC:

```{r}
bbmle::AICtab(m1, m2)
```

So we are estimating 2 extra parameters as part of the spatial correlation
structure, but the AIC strongly supports adding this model complexity. 

A disadvantage of modeling spatial correlation this way is that there is no
easy way to extract a spatial surface of predictions. An alternative and common
way of dealing with spatial autocorrelation is to model the spatial process as
a two-dimensional smooth term with a GAM. GAMs are beyond the scope of this
workshop, but it's important to know that they exist.

GAMs are just like GLMs except that predictors can be allowed to follow
a smoothed squiggly line. And the degree of squiggliness can be determined
objectively within the fitting algorithm.

As a demonstration, we will fit version of this model with a GAM. The main
package for fitting these models in R is mgcv. We will refit the `gls` model
with maximum likelihood so that we can compare it to the GAM.

```{r}
library(mgcv)
m1_ml <- gls(yield ~ variety - 1, data = d, method = "ML")
m_gam1 <- gam(yield ~ variety - 1, data = d) # the same
bbmle::AICtab(m_gam1, m1_ml)
m_gam2 <- gam(yield ~ variety - 1 + te(latitude, longitude), data = d)

bbmle::AICtab(m_gam1, m_gam2)
```

We can now plot of the spatial predictions:

```{r}
plot(m_gam2, pers = TRUE)
```

And inspected the residuals spatially as before:

```{r}
d$res_gam2 <- as.numeric(residuals(m_gam2))
ggplot(d, aes(longitude, latitude, colour = res_gam2)) + 
  geom_point(size = 5) + scale_color_gradient2()
```

